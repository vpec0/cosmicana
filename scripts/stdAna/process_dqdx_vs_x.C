/**
 * Processes the standard ana files.
 *
 * First attempt on simple electron life-time measurement
 *
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"

#include "common.icc"

int whichTPC(double);

const double kXtoT = 1./160.563; // converts cm to ms, calculated for field 0.5kV/cm and temperature 87K

void process_dqdx_vs_x(const char* fname = "", const char* outpref = "",
		       int batchNo = 20002100, size_t Nruns = 10, size_t startRun = 0,
		       const char* data_version = "v08_34_00", const char* source = "")
{
    enum {
	Dqdx_vs_x = 0,
	Dqdx_vs_x_plane0,
	Dqdx_vs_x_plane1,
	Dqdx_vs_x_plane2,
	Dqdx_vs_t,
	Dqdx_vs_t_plane0,
	Dqdx_vs_t_plane1,
	Dqdx_vs_t_plane2,
	NHists
    };

    enum {
	Dedx_vs_x = 0,
	Dedx_vs_x_plane0,
	Dedx_vs_x_plane1,
	Dedx_vs_x_plane2,
	Dedx_vs_t,
	Dedx_vs_t_plane0,
	Dedx_vs_t_plane1,
	Dedx_vs_t_plane2,
	NHists_dedx
    };

    TH1* hists[NHists] = {};
#define H1(name, title, nbins, low, high) hists[name] = new TH1F(#name, title, nbins, low, high)
#define H2(name, title, nbinsx, lowx, highx, nbinsy, lowy, highy) hists[name] = new TH2F(#name, title, nbinsx, lowx, highx, nbinsy, lowy, highy)

    H2(Dqdx_vs_x, "dQ/dx vs x;x [cm]", 400, -800, 800, 400, 0, 800);
    H2(Dqdx_vs_x_plane0, "dQ/dx vs x plane 0;x [cm]", 400, -800, 800, 400, 0, 800);
    H2(Dqdx_vs_x_plane1, "dQ/dx vs x plane 1;x [cm]", 400, -800, 800, 400, 0, 800);
    H2(Dqdx_vs_x_plane2, "dQ/dx vs x plane 2;x [cm]", 400, -800, 800, 400, 0, 800);

    H2(Dqdx_vs_t, "dQ/dx vs t;t [ms]", 400, -5, 5, 400, 0, 800);
    H2(Dqdx_vs_t_plane0, "dQ/dx vs t plane 0;t [ms]", 400, -5, 5, 400, 0, 800);
    H2(Dqdx_vs_t_plane1, "dQ/dx vs t plane 1;t [ms]", 400, -5, 5, 400, 0, 800);
    H2(Dqdx_vs_t_plane2, "dQ/dx vs t plane 2;t [ms]", 400, -5, 5, 400, 0, 800);

#undef H1
#undef H2
   TH1* hists_corrected[NHists_dedx] = {};
#define H1(name, title) hists_corrected[name] =			    \
       new TH2F(#name"_corr", Form("dQ/dx vs x%s Corrected;x [cm]",title), \
		400, -800, 800, 400, 0, 800 )
#define H2(name, title) hists_corrected[name] =			    \
       new TH2F(#name"_corr", Form("dQ/dx vs x%s Corrected;t [ms]",title), \
		400, -5, 5, 400, 0, 800 )

    H1(Dqdx_vs_x, "");
    H1(Dqdx_vs_x_plane0, " plane 0");
    H1(Dqdx_vs_x_plane1, " plane 1");
    H1(Dqdx_vs_x_plane2, " plane 2");

    H2(Dqdx_vs_t, "");
    H2(Dqdx_vs_t_plane0, " plane 0");
    H2(Dqdx_vs_t_plane1, " plane 1");
    H2(Dqdx_vs_t_plane2, " plane 2");

#undef H1
#undef H2
   TH1* hists_dedx[NHists_dedx] = {};
#define H1(name, title) hists_dedx[name] = new TH2F(#name, Form("dE/dx vs x%s;x [cm]",title), 400, -800, 800, 400, 0, 10 )
#define H2(name, title) hists_dedx[name] = new TH2F(#name, Form("dE/dx vs x%s;t [ms]",title), 400, -5, 5, 400, 0, 10 )

    H1(Dedx_vs_x, "");
    H1(Dedx_vs_x_plane0, " plane 0");
    H1(Dedx_vs_x_plane1, " plane 1");
    H1(Dedx_vs_x_plane2, " plane 2");

    H2(Dedx_vs_t, "");
    H2(Dedx_vs_t_plane0, " plane 0");
    H2(Dedx_vs_t_plane1, " plane 1");
    H2(Dedx_vs_t_plane2, " plane 2");

    //***** Input tree *****
    auto tree = new TChain("analysistree/anatree");
    size_t size = attachFiles(tree, fname, batchNo, Nruns, startRun, data_version, source);
    anatree* evt = new anatree(tree);

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	// "run",
	// "event",
    	// "geant_list_size",
	// "inTPCActive",
	// "Eng",
	// "Mother",
	// "TrackId",
	// "pdg",
	// "processname",
	// "StartE_tpcAV",
	// "StartPx_tpcAV",
	// "StartPy_tpcAV",
	// "StartPz_tpcAV",
	// "StartP_tpcAV",
	// "EndE_tpcAV",
	// "EndPointx",
	// "EndPointy",
	// "EndPointz",
	// "EndPointx_tpcAV",
	// "EndPointy_tpcAV",
	// "EndPointz_tpcAV",
	// "pathlen",
	"ntracks_pandoraTrack",
	"ntrkhits_pandoraTrack",
	"trkdqdx_pandoraTrack",
	"trkdedx_pandoraTrack",
	"trkxyz_pandoraTrack",
	"trklen_pandoraTrack"
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);
    tree->SetMakeClass(1);

    //***** Process *****
    cout<<"Starting a loop over the tree"<<endl;
    int entries_processed = 0;
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;


    size_t events_passing_selection = 0;
    size_t tracks_passing_selection = 0;

    //size = 50000;
    cout<<"|                                                  |\r|";
    size_t ientry = 0;
    while ( tree->GetEntry(ientry++) ) {
	// print progress
	if ( (ientry)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	entries_processed++;
	int ntracks = evt->ntracks_pandoraTrack;

	// loop over stored tracks
	bool passed = false ;
	for (int itrack = 0; itrack < ntracks; ++itrack) {
	    // make a threshold on reco track length
	    if (evt->trklen_pandoraTrack[itrack] < 200.) continue; // at least 2-m long track
	    if (!passed) passed = true;

	    ++tracks_passing_selection;

	    // choose the best plane
	    int best_plane = 0;
	    int tmp_hits = 0;
	    for (int i = 0; i < 3; ++i) {
		if ( evt->ntrkhits_pandoraTrack[itrack][i] > tmp_hits ) {
		    tmp_hits = evt->ntrkhits_pandoraTrack[itrack][i];
		    best_plane = i;
		}
	    }

	    // loop over all planes
	    // loop over hits in the best plane
	    //
	    // FIXME: Before using this code, tmp_hits needs to be
	    // fixed! Similarly to how it's done in DqDxProcessor
	    for (int iplane = 0; iplane < 3; ++iplane) {
		for (int i = 0; i < tmp_hits; ++i) {
		    double dqdx = evt->trkdqdx_pandoraTrack[itrack][iplane][i];
		    double dedx = evt->trkdedx_pandoraTrack[itrack][iplane][i];
		    if ( dqdx != 0.) {
			double x = evt->trkxyz_pandoraTrack[itrack][iplane][i][0];
			double t = x * kXtoT;

			hists[Dqdx_vs_x_plane0 + iplane]->Fill(x, dqdx);
			hists[Dqdx_vs_t_plane0 + iplane]->Fill(t, dqdx);

			if (iplane == best_plane) {
			    hists[Dqdx_vs_x]->Fill(x, dqdx);
			    hists[Dqdx_vs_t]->Fill(t, dqdx);
			}

			// do corrections, only within main TPCs
			if ( x > APA_X_POSITIONS[0]
			     && x < APA_X_POSITIONS[2] ) {
			    // get the hits drift time from the point's x coordinate
			    int tpc = whichTPC(x);
			    double dt = ( -1 + 2*((tpc+1)%2) )*(x - APA_X_POSITIONS[(tpc+1)/2]);
			    dt *= kXtoT;
			    double correction = TMath::Exp(-dt/2.88);
			    double dqdx_corrected = dqdx/correction;

			    hists_corrected[Dqdx_vs_x_plane0 + iplane]->Fill(x, dqdx_corrected);
			    hists_corrected[Dqdx_vs_t_plane0 + iplane]->Fill(t, dqdx_corrected);
			    if (iplane == best_plane) {
				hists_corrected[Dqdx_vs_x]->Fill(x, dqdx_corrected);
				hists_corrected[Dqdx_vs_t]->Fill(t, dqdx_corrected);
			    }
			}
		    }
		    if ( dedx != 0.) {
			double x = evt->trkxyz_pandoraTrack[itrack][iplane][i][0];
			double t = x * kXtoT;
			hists_dedx[Dedx_vs_x_plane0 + iplane]->Fill(x, dedx);
			hists_dedx[Dedx_vs_t_plane0 + iplane]->Fill(t, dedx);
			if (iplane == best_plane) {
			    hists_dedx[Dedx_vs_x]->Fill(x, dedx);
			    hists_dedx[Dedx_vs_t]->Fill(t, dedx);
			}
		    }
		}
	    }

	}// track loop

	if (passed)
	    ++events_passing_selection;

    }// tree entry loop
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;
    cout<<"Events passing selection: "<<events_passing_selection<<endl
	<<"Tracks passing selection: "<<tracks_passing_selection<<endl;

    //***** Output file *****
    auto outf = TFile::Open(Form("%sanahists.root", outpref), "UPDATE");

    //***** Save hists *****
    for (auto h : hists) {
	h->Write(0, TObject::kOverwrite);
    }

    for (auto h : hists_corrected) {
	h->Write(0, TObject::kOverwrite);
    }

    for (auto h : hists_dedx) {
	h->Write(0, TObject::kOverwrite);
    }

    outf->Close();
    cout<<"Saved and closed output file "<<outf->GetName()<<endl;
}

int whichTPC(double x) {
    int i = 0;
    for (; i < 4; ++i) {
	int iapa = (i+1)/2;
	int icpa = i/2;
	double xapa = APA_X_POSITIONS[iapa];
	double xcpa = CPA_X_POSITIONS[icpa];
	if ( (x > xapa && x < xcpa) || (x < xapa && x > xcpa) )
	    break;
    }

    return i;
}
