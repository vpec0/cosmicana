/**
 * Processes the standard ana files.
 *
 * Gets some basic counts and creates histograms of some basic distributions
 *
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"

#include "common.icc"

void doXlog(TH1* h);

void process_ana_basic(const char* fname = "", const char* outpref = "",
		       size_t batchNo = 20002100, size_t Nruns = 10, size_t startRun = 0,
		       const char* data_version = "v08_34_00")
{
    enum {
	E_gen = 0,
	Phi_fnal_gen,
	Phi_east_gen,
	Theta_gen,
	E_all,
	E_primary,
	E_secondary,
	E_gen_logx,
	E_all_logx,
	E_primary_logx,
	E_secondary_logx,
	Phi_fnal,
	Phi_east,
	Theta,
	Path_primary,
	Path_secondary,
	Eloss,
	Eloss_logx,
	Elosspath,
	Elosspath_logx,
	EMichel_all,
	EMichel_primary,
	Epi0,
	Epi0_logx,
	Npi0,
	Ek,
	Ek_logx,
	Klen,
	Klen_logx,
	Nk,
	Ntracks,
	Nshowers,
	NHists
    };

    TH1* hists[NHists] = {};
#define H1(name, title, nbins, low, high) hists[name] = new TH1F(#name, title, nbins, low, high)

    H1(E_gen, "Energy of generated muons;Energy [GeV]", 2000, 0, 20e3);
    H1(Phi_fnal_gen, "Azimuth angle from direction to FNAL;#phi_{FNAL} [#circ]", 360, 0, 360); // from -Z axis, clock-wise in XZ plane
    H1(Phi_east_gen, "Azimuth angle from east direction;#phi_{east} [#circ]", 360, 0, 360); // from -Z axis, clock-wise in XZ plane
    H1(Theta_gen, "Zenith angle;cos(#theta)", 200, -1, 1); // from -Z axis, clock-wise in XZ plane
    H1(E_all, "Energy of all muons in TPC;Energy [GeV]", 2000, 0, 20e3);
    H1(E_primary, "Energy of primary muons in TPC;Energy [GeV]", 2000, 0, 20e3);
    H1(E_secondary, "Energy of secondary muons in TPC;Energy [GeV]", 200, 0, 2);

    H1(E_gen_logx, "Energy of generated muons;Energy [GeV];[GeV^{-1}]", 240, 0.1, 1e5);
    H1(E_all_logx, "Energy of all muons in TPC;Energy [GeV];[GeV^{-1}]", 240, 0.1, 1e5);
    H1(E_primary_logx, "Energy of primary muons in TPC;Energy [GeV];[GeV^{-1}]", 240, 0.1, 1e5);
    H1(E_secondary_logx, "Energy of secondary muons in TPC;Energy [GeV];[GeV^{-1}]", 200, 0.1, 10);
    for (int i = E_gen_logx; i <= E_secondary_logx; ++i)
	doXlog(hists[i]);

    H1(Phi_fnal, "Azimuth angle from direction to FNAL;#phi_{FNAL} [#circ]", 360, 0, 360); // from -Z axis, clock-wise in XZ plane
    H1(Phi_east, "Azimuth angle from east direction;#phi_{east} [#circ]", 360, 0, 360); // from -Z axis, clock-wise in XZ plane
    H1(Theta, "Zenith angle;cos(#theta)", 200, -1, 1); // from -Z axis, clock-wise in XZ plane

    H1(Path_primary, "Path length of primary muons in TPC;Path [m]", 300, 0, 30);
    H1(Path_secondary, "Path length of secondary muons in TPC;Path [m]", 1000, 0, 10);

    H1(Eloss, "Energy loss of primary muons in TPC;Energy [GeV]", 1300, 0, 1300);
    H1(Eloss_logx, "Energy loss of primary muons in TPC;Energy [GeV];[GeV^{-1}]", 200, 0.1, 1e4);
    doXlog(hists[Eloss_logx]);

    H1(Elosspath, "Energy loss/path length for primary muons in TPC;dE/dx [MeV/cm]", 1300, 0, 1300);
    H1(Elosspath_logx, "Energy loss/path length for primary muons in TPC;dE/dx [MeV/cm];[(MeV/cm)^{-1}]", 200, 0.1, 1e4);
    doXlog(hists[Elosspath_logx]);

    H1(EMichel_all, "Energy of all Michel electrons in TPC;Energy [MeV]", 1000, 0, 100);
    H1(EMichel_primary, "Energy of Michel electrons from primary muon in TPC;Energy [MeV]", 1000, 0, 100);

    H1(Epi0, "Energy of #pi^{0} in TPC;Energy [GeV]", 1000, 0, 100);
    H1(Epi0_logx, "Energy of #pi^{0} in TPC;Energy [GeV];[GeV^{-1}]", 300, 0.1, 100);
    doXlog(hists[Epi0_logx]);
    H1(Npi0, "Number of #pi^{0} in TPC in one event;Number of #pi^{0}", 200, 0, 200);

    // K related
    H1(Ek, "Energy of kaons in TPC;Energy [GeV]", 1000, 0, 100);
    H1(Ek_logx, "Energy of kaons in TPC;Energy [GeV];[GeV^{-1}]", 300, 0.1, 100);
    doXlog(hists[Ek_logx]);

    H1(Klen, "Path length of kaons in TPC;Path length [cm]", 600, 0, 600);
    H1(Klen_logx, "Path length of kaons in TPC;Path length [cm];[cm^{-1}]", 200, 0.1, 1000);
    doXlog(hists[Klen_logx]);

    H1(Nk, "Number of kaons in TPC in one event;Number of kaons", 200, 0, 200);

    // Reco related
    H1(Ntracks, "Number of reconstructed tracks;No. of reco tracks", 50, 0, 50); // pandora
    H1(Nshowers, "Number of reconstructed showers;No. of reco showers", 50, 0, 50); // EmShower


    //***** Input tree *****
    auto tree = new TChain("analysistree/anatree");
    size_t size = attachFiles(tree, fname, batchNo, Nruns, startRun, data_version);
    anatree* evt = new anatree(tree);

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	"run",
	"event",
    	"geant_list_size",
	"inTPCActive",
	"Eng",
	"Px", "Py", "Pz", "P",
	"Mother",
	"TrackId",
	"pdg",
	"processname",
	"StartE_tpcAV",
	"StartPx_tpcAV",
	"StartPy_tpcAV",
	"StartPz_tpcAV",
	"StartP_tpcAV",
	"EndE_tpcAV",
	"EndPointx",
	"EndPointy",
	"EndPointz",
	"EndPointx_tpcAV",
	"EndPointy_tpcAV",
	"EndPointz_tpcAV",
	"pathlen",
	"ntracks_pandoraTrack",
	"nshowers_emshower"
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);


    //***** Process *****
    int n_evts_in_tpc = 0;
    int n_michel_total = 0;
    int n_michel_primary = 0;
    int n_mu_in_tpc_all = 0;
    int n_mu_stopped_in_tpc_all = 0;
    int n_mu_stopped_in_tpc_primary = 0;
    int n_pi0 = 0;
    int n_pi0_events = 0;
    int n_k_events = 0;
    int n_k = 0;

    TString decay_name = "decay";
    TString capture_name = "muminuscaptureatrest";

    cout<<"Starting a loop over the tree"<<endl;
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;

    int cut_passed[8] = {};
    int entries_processed = 0;

    //size = 50000;
    cout<<"|                                                  |\r|";
    size_t ientry = 0;
    while (tree->GetEntry(ientry++)) {
	// print progress
	if ( (ientry)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	// get an entry
	entries_processed++;
	int nparticles = evt->geant_list_size;

	// print info on entries where there was an overflow
	if (nparticles > MAX_G4_PARTICLES)
	    cerr<<"Limits on number of g4 particles set too low. Got "
		<<nparticles<<" particles in the file, while the limit is set to "
		<<MAX_G4_PARTICLES<<endl;

	// create a map of track id to pdg code (to be able to look up mother's pdg)
	map<int,int> trkId2pdgMap;
	for (int ipart = 0; ipart < nparticles; ++ipart)
	    trkId2pdgMap[evt->TrackId[ipart]] = evt->pdg[ipart];

	for (int ipart = 0; ipart < nparticles; ++ipart) {
	    if (evt->inTPCActive[ipart]) {
		n_evts_in_tpc++;
		break;
	    }
	}

	// Fill histograms
	//
	// reco info
	hists[Ntracks]->Fill(evt->ntracks_pandoraTrack);
	hists[Nshowers]->Fill(evt->nshowers_emshower);

	// gen energies
	hists[E_gen]->Fill(evt->Eng[0]); // assuming primary is always stored first
	hists[E_gen_logx]->Fill(evt->Eng[0]); // assuming primary is always stored first

	// gen direction
	double phi = TMath::ATan2(-evt->Px[0], -evt->Pz[0]);
	phi *= 180./TMath::Pi(); // convert to degrees
	phi += 180; // shift to start from -Z axis
	hists[Phi_fnal_gen]->Fill(phi);
	hists[Phi_east_gen]->Fill((phi<7.)?(phi-7)+360:phi-7);
	hists[Theta_gen]->Fill(-evt->Py[0]/evt->P[0]);


	// in TPC energy, path length, energy loss
	if (evt->inTPCActive[0]) {
	    hists[E_primary]->Fill(evt->StartE_tpcAV[0]); // assuming primary is always stored first
	    hists[E_primary_logx]->Fill(evt->StartE_tpcAV[0]);

	    hists[Path_primary]->Fill(evt->pathlen[0] * 0.01); // convert to metres

	    double eloss = evt->StartE_tpcAV[0] - evt->EndE_tpcAV[0];
	    hists[Eloss]->Fill(eloss);
	    hists[Eloss_logx]->Fill(eloss);
	    eloss *= 1e3 / evt->pathlen[0];
	    hists[Elosspath]->Fill(eloss);
	    hists[Elosspath_logx]->Fill(eloss);

	    // angular distro
	    // wherefrom muon arrives, azimuthal angle from Z axis, counterclockwise
	    double phi = TMath::ATan2(-evt->StartPx_tpcAV[0], -evt->StartPz_tpcAV[0]);
	    phi *= 180./TMath::Pi(); // convert to degrees
	    phi += 180; // shift to start from -Z axis
	    hists[Phi_fnal]->Fill(phi);
	    hists[Phi_east]->Fill((phi<7.)?(phi-7)+360:phi-7);
	    hists[Theta]->Fill(-evt->StartPy_tpcAV[0]/evt->StartP_tpcAV[0]);
	}

	int current_n_pi0 = 0;
	int current_n_k = 0;

	// loop over stored particle, find Michel electrons
	for (int ipart = 0; ipart < nparticles; ++ipart) {
	    // TPC active volume quantities
	    if ( !evt->inTPCActive[ipart] ) continue; // not in the active volume
	    cut_passed[0]++;

	    if (abs(evt->pdg[ipart]) == 13) { // a muon
		n_mu_in_tpc_all++;
		// fill a muon in TPC
		hists[E_all]->Fill(evt->StartE_tpcAV[ipart]);
		hists[E_all_logx]->Fill(evt->StartE_tpcAV[ipart]);
		if (evt->Mother[ipart] != 0) { // not the primary muon
		    hists[E_secondary]->Fill(evt->StartE_tpcAV[ipart]);
		    hists[E_secondary_logx]->Fill(evt->StartE_tpcAV[ipart]);
		    hists[Path_secondary]->Fill(evt->pathlen[ipart] * 0.01); // convert to metres
		}

		// count stopping muons
		double dx = abs(evt->EndPointx[ipart] - evt->EndPointx_tpcAV[ipart]);
		double dy = abs(evt->EndPointy[ipart] - evt->EndPointy_tpcAV[ipart]);
		double dz = abs(evt->EndPointz[ipart] - evt->EndPointz_tpcAV[ipart]);

		if ( (dx+dy+dz) < 1e-10 ) {
		    // global endpoint of the particle is tpcAV endpoint
		    // muon stopped in tpcAV
		    n_mu_stopped_in_tpc_all++;
		    if (evt->Mother[ipart] == 0) // primary muon
			n_mu_stopped_in_tpc_primary++;
		}
	    }

	    // count produced pi0's
	    if (abs(evt->pdg[ipart]) == 111) { // a pi0
		current_n_pi0++;
		hists[Epi0]->Fill(evt->Eng[ipart]);
		hists[Epi0_logx]->Fill(evt->Eng[ipart]);

		// cout<<"Entry: "<<ientry
		//     <<" Event: "<<evt->event
		//     <<" pdg["<<ipart<<"]: "<<evt->pdg[ipart]
		//     <<" inTPCActive: "<<evt->inTPCActive[ipart]<<endl;
	    }

	    // count produced charged kaons
	    if (abs(evt->pdg[ipart]) == 321) { // a kaon
		current_n_k++;
		hists[Ek]->Fill(evt->Eng[ipart]);
		hists[Ek_logx]->Fill(evt->Eng[ipart]);

		hists[Klen]->Fill(evt->pathlen[ipart]);
		hists[Klen_logx]->Fill(evt->pathlen[ipart]);

		// cout<<"Entry: "<<ientry
		//     <<" Event: "<<evt->event
		//     <<" pdg["<<ipart<<"]: "<<evt->pdg[ipart]
		//     <<" inTPCActive: "<<evt->inTPCActive[ipart]<<endl;
	    }

	    if ( abs(evt->pdg[ipart] ) != 11 ) continue; // not an electron, not interested
	    cut_passed[1]++;

	    int mother = evt->Mother[ipart];
	    if (trkId2pdgMap.find(mother) == trkId2pdgMap.end())
		continue; // mother particle not stored, will not get its pdg
	    cut_passed[2]++;

	    int mother_pdg = trkId2pdgMap.at(mother);
	    if ( abs(mother_pdg) != 13 ) continue; // mother not a muon
	    cut_passed[3]++;

	    TString proc_name = evt->processname->at(ipart);
	    proc_name.ToLower();
	    if ( decay_name != proc_name && capture_name != proc_name )
		continue; // creator process not a muon decay
	    cut_passed[4]++;

	    double energy = evt->Eng[ipart] * 1e3; // convert to MeV
	    if ( mother_pdg > 0 && energy < 2.)
		continue; // mother mu- but energy too low for a Michel electron
	    cut_passed[5]++;

	    // we have a Michel electron
	    n_michel_total++;
	    hists[EMichel_all]->Fill(energy);
	    if (mother == 1) { // daughter of the primary muon
		n_michel_primary++;
		hists[EMichel_primary]->Fill(energy);
	    }
	}// particle loop

	// count total pi0 in this events
	n_pi0 += current_n_pi0;
	if (current_n_pi0) {
	    n_pi0_events++;
	    hists[Npi0]->Fill(current_n_pi0);
	}

	// count total kaons in this event
	n_k += current_n_k;
	if (current_n_k) {
	    n_k_events++;
	    hists[Nk]->Fill(current_n_k);
	}

    }// tree entry loop
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;
    cout<<"Cuts passed: "<<endl;
    for (int i = 0; i < 6; i++) {
	cout<<i<<": "<<cut_passed[i]<<endl;
    }

    cout<<"In TPC AV:"<<endl;

    cout<<"Total events in TPC: "<<n_evts_in_tpc<<endl;
    cout<<"Total primary muons in TPC: "<<hists[E_primary]->GetEntries()<<endl;
    cout<<"Total muons in TPC: "<<n_mu_in_tpc_all<<endl;
    cout<<"Muons stopped total: "<<n_mu_stopped_in_tpc_all<<endl
	<<"Muons stopped primary: "<<n_mu_stopped_in_tpc_primary<<endl;
    cout<<endl;
    cout<<"Michel electrons total: "<<n_michel_total<<endl
	<<"Michel electrons primary: "<<n_michel_primary<<endl;
    cout<<endl;
    cout<<"Pi0 produced: "<<n_pi0<<endl;
    cout<<"Number of events with pi0 produced: "<<n_pi0_events<<endl;
    cout<<endl;
    cout<<"Kons produced: "<<n_k<<endl;
    cout<<"Number of events with kaons produced: "<<n_k_events<<endl;


    //***** Output file *****
    auto outf = TFile::Open(Form("%sanahists.root", outpref), "UPDATE");

    //***** Save hists *****
    for (auto h : hists) {
	h->Write(0, TObject::kOverwrite);
    }

    outf->Close();
    cout<<"Saved and closed output file"<<endl;
}
