/**
 * Processes the standard ana files.
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"
#define BASICANATREE_CXX
#include "BasicAnaTree.h"
#include "FileHandler.h"

#define FOR(i, size) for (int i = 0; i < size; i++)

void process_standard_plot_tree(const char* fname = "", const char* outfname = "",
				int batchNo=0, int Nruns=1, int startRun=0,
				const char* basedir = "", const char* version = "v09_42_00_01")
{
    // gROOT->ProcessLine("gErrorIgnoreLevel = 6001;");


    //***** Input tree *****
    TString suffix = "";
    TString ffname = fname;
    if (!strstr(fname, ".root")) {
	suffix = fname;
	ffname = "";
    }
    auto tree = new TChain("analysistree/anatree");
    size_t size = FileHandler::attachFiles(tree, ffname, batchNo, Nruns, startRun, version, suffix, basedir);
    anatree* evt = new anatree(tree);

    cout << "Input file name:" << tree->GetFile()->GetName()<<endl;

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	"run",
	"event",
    	"geant_list_size",
	"inTPCActive",
	"Eng",
	"Px", "Py", "Pz", "P",
	"Mother",
	// "TrackId",
	// "pdg",
	// "processname",
	"StartE_tpcAV",
	"StartPx_tpcAV",
	"StartPy_tpcAV",
	"StartPz_tpcAV",
	"StartP_tpcAV",
	"EndE_tpcAV",
	"StartPointx",
	"StartPointy",
	"StartPointz",
	"EndPointx",
	"EndPointy",
	"EndPointz",
	"EndPointx_tpcAV",
	"EndPointy_tpcAV",
	"EndPointz_tpcAV",
	"pathlen",
	"ntracks_pandoraTrack",
	"trkg4id_pandoraTrack",
	"trklen_pandoraTrack",
	"trkstartx_pandoraTrack",
	"trkstarty_pandoraTrack",
	"trkstartz_pandoraTrack",
	"trkendx_pandoraTrack",
	"trkendy_pandoraTrack",
	"trkendz_pandoraTrack"
	//"nshowers_emshower"
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);

    //***** Output tree *****
    auto outf = TFile::Open(outfname, "recreate");
    auto bat = new BasicAnaTree();
    auto outtree = bat->fTree;



    //***** Process *****
    int n_evts_in_tpc = 0;
    int n_michel_total = 0;
    int n_michel_primary = 0;
    int n_mu_in_tpc_all = 0;
    int n_mu_stopped_in_tpc_all = 0;
    int n_mu_stopped_in_tpc_primary = 0;
    int n_pi0 = 0;
    int n_pi0_events = 0;
    int n_k_events = 0;
    int n_k = 0;

    TString decay_name = "decay";
    TString capture_name = "muminuscaptureatrest";

    cout<<"Starting a loop over the input tree"<<endl;
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;

    int cut_passed[8] = {};
    int entries_processed = 0;

    //size = 50000;
    cout<<"|                                                  |\r|";
    size_t ientry = 0;
    while (tree->GetEntry(ientry++)) {
	// print progress
	if ( (ientry)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	// get an entry
	entries_processed++;
	int nparticles = evt->geant_list_size;

	// print info on entries where there was an overflow
	// if (nparticles > MAX_G4_PARTICLES)
	//     cerr<<"Limits on number of g4 particles set too low. Got "
	// 	<<nparticles<<" particles in the file, while the limit is set to "
	// 	<<MAX_G4_PARTICLES<<endl;

	for (int ipart = 0; ipart < nparticles; ++ipart) {
	    if (evt->inTPCActive[ipart]) {
		n_evts_in_tpc++;
		break;
	    }
	}

	// Fill tree leaves
	bat->run = evt->run;
	bat->event = evt->event;

	// gen energies
	bat->E = evt->Eng[0]; // assuming primary is always stored first

	// gen direction
	double phi = TMath::ATan2(-evt->Py[0], -evt->Pz[0]); // VD assumed (x is vertical)
	phi *= 180./TMath::Pi(); // convert to degrees
	//phi += 180; // shift to start from -Z axis
	bat->phi = phi;
	bat->costheta = -evt->Px[0]/evt->P[0]; // VD assumed (x is vertical)
	//     hists[Phi_fnal]->Fill(phi);
	//     hists[Phi_east]->Fill((phi<7.)?(phi-7)+360:phi-7);


	bat->len_tpc = evt->pathlen[0]; // convert to metres
	double eloss = evt->StartE_tpcAV[0] - evt->EndE_tpcAV[0];
	bat->Edep_tpc = eloss;

	bat->start[0] = evt->StartPointx[0];
	bat->start[1] = evt->StartPointy[0];
	bat->start[2] = evt->StartPointz[0];

	bat->end[0] = evt->EndPointx_tpcAV[0];
	bat->end[1] = evt->EndPointy_tpcAV[0];
	bat->end[2] = evt->EndPointz_tpcAV[0];

	// count stopping muons
	double dx = abs(evt->EndPointx[0] - evt->EndPointx_tpcAV[0]);
	double dy = abs(evt->EndPointy[0] - evt->EndPointy_tpcAV[0]);
	double dz = abs(evt->EndPointz[0] - evt->EndPointz_tpcAV[0]);

	bat->stopped = ( (dx+dy+dz) < 1e-10 );

	// reco info
	bat->nTracks = evt->ntracks_pandoraTrack;
	int nprimaries = 0;
	FOR(itrk, evt->ntracks_pandoraTrack) {
	    if (evt->trkg4id_pandoraTrack[itrk] == 1) { // primary muon
		//FIXME: fill track length and start/end positions
		bat->trk_len[nprimaries] = evt->trklen_pandoraTrack[itrk];
		bat->trk_start[nprimaries][0] = evt->trkstartx_pandoraTrack[itrk];
		bat->trk_start[nprimaries][1] = evt->trkstarty_pandoraTrack[itrk];
		bat->trk_start[nprimaries][2] = evt->trkstartz_pandoraTrack[itrk];
		bat->trk_end[nprimaries][0] = evt->trkendx_pandoraTrack[itrk];
		bat->trk_end[nprimaries][1] = evt->trkendy_pandoraTrack[itrk];
		bat->trk_end[nprimaries][2] = evt->trkendz_pandoraTrack[itrk];
		nprimaries++;
	    }
	}
	bat->nTracksPrimary = nprimaries;


	outtree->Fill();
	bat->clear();
    }// tree entry loop
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;
    cout<<"Cuts passed: "<<endl;
    for (int i = 0; i < 6; i++) {
	cout<<i<<": "<<cut_passed[i]<<endl;
    }

    cout<<"In TPC AV:"<<endl;

    cout<<"Total events in TPC: "<<n_evts_in_tpc<<endl;
    cout<<"Total muons in TPC: "<<n_mu_in_tpc_all<<endl;
    cout<<"Muons stopped total: "<<n_mu_stopped_in_tpc_all<<endl
	<<"Muons stopped primary: "<<n_mu_stopped_in_tpc_primary<<endl;
    cout<<endl;
    cout<<"Michel electrons total: "<<n_michel_total<<endl
	<<"Michel electrons primary: "<<n_michel_primary<<endl;
    cout<<endl;
    cout<<"Pi0 produced: "<<n_pi0<<endl;
    cout<<"Number of events with pi0 produced: "<<n_pi0_events<<endl;
    cout<<endl;
    cout<<"Kons produced: "<<n_k<<endl;
    cout<<"Number of events with kaons produced: "<<n_k_events<<endl;


    //***** Output file *****
    outtree->Write();
    outf->Close();
    cout<<"Saved and closed output file"<<endl;
}
