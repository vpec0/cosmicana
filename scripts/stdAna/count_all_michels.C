/**
 * Count all Michel electrons
 *
 * Michel electron found as a daughter of a muon, its creator process
 * name is either Deacy or MuMinusCaptureAtRest.
 *
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"


void count_all_michels(const char* fname = "", const char* outpref = "")
{
    enum {
	kE_all = 0,
	kE_primary,
	kPhi,
	kTheta,
	kNHists
    };


    auto hE_all = new TH1F("hE_all", "Energy of all Michel electrons;Energy [MeV]", 120, 0, 60);
    auto hE_primary = new TH1F("hE_primary", "Energy of Michel electrons from primary muons"
			       ";Energy [MeV]", 120, 0, 60);

    //***** Input tree *****
    TChain* tree = 0;
    if (!strcmp(fname, "")) { // no input given
	cout<<"Will add all production files to the chain (unchecked)."<<endl;
	tree = new TChain("analysistree/anatree");
	for (int i = 21; i<=30; i++) {
	    TString topdir = Form("data/kumar/2000%02d00/", i);
	    for (int j = 0; j<100; j++) {
		TString fname = topdir +
		    Form("2000%02d%02d/MUSUN_dunefd_2000%02d%02d_gen_g4_detsim_reco_ana.root",i,j,i,j);
		int status = tree->Add(fname, 500);
	    }
	}
    } else { // input given
	cout<<"Adding "<<fname<<" to the chain."<<endl;
	tree = new TChain("analysistree/anatree");
	int status = tree->Add(fname, -1);
	if (!status) { // try to look in the base dir
	    tree->SetName("anatree");
	    status = tree->Add(fname, -1);
	}
	cout<<"Status: "<<status<<endl;
    }

    anatree* evt = new anatree(tree);

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	"run",
	"event",
    	"geant_list_size",
	"inTPCActive",
	"Eng",
	"Mother",
	"TrackId",
	"pdg",
	"processname",
	"EndPointx",
	"EndPointy",
	"EndPointz",
	"EndPointx_tpcAV",
	"EndPointy_tpcAV",
	"EndPointz_tpcAV"
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);


    //***** Process *****
    int n_michel_total = 0;
    int n_michel_primary = 0;
    int n_mu_stopped_in_tpc_all = 0;
    int n_mu_stopped_in_tpc_primary = 0;
    int n_pi0 = 0;

    TString decay_name = "decay";
    TString capture_name = "muminuscaptureatrest";

    cout<<"Starting a loop over the tree"<<endl;
    int size = tree->GetEntriesFast();
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;

    int cut_passed[8] = {};
    int entries_processed = 0;

    cout<<"|                                                  |\r|";
    for (int ientry = 0; ientry < size; ++ientry) {
	if ( (ientry+1)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	int status = tree->GetEntry(ientry);
	if (!status) break;
	entries_processed++;
	int nparticles = evt->geant_list_size;
	if (nparticles > MAX_G4_PARTICLES)
	    cerr<<"Limits on number of g4 particles set too low. Got "
		<<nparticles<<" particles in the file, while the limit is set to "
		<<MAX_G4_PARTICLES<<endl;
	// create a map of track id to pdg code (to be able to look up mother's pdg)
	map<int,int> trkId2pdgMap;
	for (int ipart = 0; ipart < nparticles; ++ipart)
	    trkId2pdgMap[evt->TrackId[ipart]] = evt->pdg[ipart];

	// loop over stored particle, find Michel electrons
	for (int ipart = 0; ipart < nparticles; ++ipart) {
	    if ( !evt->inTPCActive[ipart] ) continue; // not in the active volume
	    cut_passed[0]++;

	    // count stopping muons
	    if (abs(evt->pdg[ipart]) == 13) { // a muon
		double dx = abs(evt->EndPointx[ipart] - evt->EndPointx_tpcAV[ipart]);
		double dy = abs(evt->EndPointy[ipart] - evt->EndPointy_tpcAV[ipart]);
		double dz = abs(evt->EndPointz[ipart] - evt->EndPointz_tpcAV[ipart]);

		if ( (dx+dy+dz) < 1e-10 ) {
		    // global endpoint of the particle is tpcAV endpoint
		    // muon stopped in tpcAV
		    n_mu_stopped_in_tpc_all++;
		    if (evt->Mother[ipart] == 0) // primary muon
			n_mu_stopped_in_tpc_primary++;
		}
	    }

	    // count produced pi0's
	    if (abs(evt->pdg[ipart]) == 111) { // a muon
		n_pi0++;

		// cout<<"Entry: "<<ientry
		//     <<" Event: "<<evt->event
		//     <<" pdg["<<ipart<<"]: "<<evt->pdg[ipart]
		//     <<" inTPCActive: "<<evt->inTPCActive[ipart]<<endl;
	    }

	    if ( abs(evt->pdg[ipart] ) != 11 ) continue; // not an electron, not interested
	    cut_passed[1]++;

	    int mother = evt->Mother[ipart];
	    if (trkId2pdgMap.find(mother) == trkId2pdgMap.end())
		continue; // mother particle not stored, will not get its pdg
	    cut_passed[2]++;

	    int mother_pdg = trkId2pdgMap.at(mother);
	    if ( abs(mother_pdg) != 13 ) continue; // mother not a muon
	    cut_passed[3]++;

	    TString proc_name = evt->processname->at(ipart);
	    proc_name.ToLower();
	    if ( decay_name != proc_name && capture_name != proc_name )
		continue; // creator process not a muon decay
	    cut_passed[4]++;

	    double energy = evt->Eng[ipart] * 1e3; // convert to MeV
	    if ( mother_pdg > 0 && energy < 2.)
		continue; // mother mu- but energy too low for a Michel electron
	    cut_passed[5]++;

	    n_michel_total++;
	    hE_all->Fill(energy);
	    if (mother == 1) { // daughter of the primary muon
		n_michel_primary++;
		hE_primary->Fill(energy);
	    }
	}
    }
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;
    cout<<"Cuts passed: "<<endl;
    for (int i = 0; i < 6; i++) {
	cout<<i<<": "<<cut_passed[i]<<endl;
    }

    cout<<"In TPC AV:"<<endl;

    cout<<"Muons stopped total: "<<n_mu_stopped_in_tpc_all<<endl
	<<"Muons stopped primary: "<<n_mu_stopped_in_tpc_primary<<endl;

    cout<<"Michel electrons total: "<<n_michel_total<<endl
	<<"Michel electrons primary: "<<n_michel_primary<<endl;

    cout<<"Pi0 produced: "<<n_pi0<<endl;

    // Draw the results
    auto c = new TCanvas("c", "", 600, 300);
    c->Divide(2);

    auto pad = c->cd(1);
    hE_all->Draw();

    pad = c->cd(2);
    hE_primary->Draw();

    // Save the canvas into a pdf file
    c->SaveAs(Form("%sMichel_electron_energies.pdf", outpref));




    //***** Output file *****
    auto outf = TFile::Open(Form("%sanahists.root", outpref), "UPDATE");

    //***** Save hists *****
    hE_all->Write(0, TObject::kOverwrite);
    hE_primary->Write(0, TObject::kOverwrite);

    outf->Close();
    cout<<"Saved and closed output file"<<endl;
}
