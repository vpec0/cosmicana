/**
 * Processes the standard ana files.
 *
 * First attempt on simple electron life-time measurement
 *
 * Selecting only events where muons pass clean - Eloss/pathlen ~ 3 MeV/cm
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"

#include "common.icc"

const double kXtoT = 1./160.563; // converts cm to ms, calculated for field 0.5kV/cm and temperature 87K


void process_dqdx_vs_x_clean_through(const char* fname = "", const char* outpref = "", int batchNo = 21, int Nruns = 10)
{
    enum {
	Dqdx_vs_x = 0,
	Dqdx_vs_x_plane0,
	Dqdx_vs_x_plane1,
	Dqdx_vs_x_plane2,
	Dqdx_vs_t,
	Dqdx_vs_t_plane0,
	Dqdx_vs_t_plane1,
	Dqdx_vs_t_plane2,
	NHists
    };

    TH1* hists[NHists] = {};
#define H1(name, title, nbins, low, high) hists[name] = new TH1F(#name, title, nbins, low, high)
#define H2(name, title, nbinsx, lowx, highx, nbinsy, lowy, highy) hists[name] = new TH2F(#name, title, nbinsx, lowx, highx, nbinsy, lowy, highy)

    H2(Dqdx_vs_x, "dQ/dx vs x;x [cm]", 400, -800, 800, 400, 0, 800);
    H2(Dqdx_vs_x_plane0, "dQ/dx vs x plane 0;x [cm]", 400, -800, 800, 400, 0, 800);
    H2(Dqdx_vs_x_plane1, "dQ/dx vs x plane 1;x [cm]", 400, -800, 800, 400, 0, 800);
    H2(Dqdx_vs_x_plane2, "dQ/dx vs x plane 2;x [cm]", 400, -800, 800, 400, 0, 800);

    H2(Dqdx_vs_t, "dQ/dx vs t;t [ms]", 400, -5, 5, 400, 0, 800);
    H2(Dqdx_vs_t_plane0, "dQ/dx vs t plane 0;t [ms]", 400, -5, 5, 400, 0, 800);
    H2(Dqdx_vs_t_plane1, "dQ/dx vs t plane 1;t [ms]", 400, -5, 5, 400, 0, 800);
    H2(Dqdx_vs_t_plane2, "dQ/dx vs t plane 2;t [ms]", 400, -5, 5, 400, 0, 800);

    //***** Input tree *****
    auto tree = new TChain("analysistree/anatree");
    attachFiles(tree, fname, batchNo, Nruns);
    anatree* evt = new anatree(tree);

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	// "run",
	// "event",
    	"geant_list_size",
	"inTPCActive",
	// "Eng",
	// "Mother",
	// "TrackId",
	// "pdg",
	// "processname",
	"StartE_tpcAV",
	// "StartPx_tpcAV",
	// "StartPy_tpcAV",
	// "StartPz_tpcAV",
	// "StartP_tpcAV",
	"EndE_tpcAV",
	"EndPointx",
	// "EndPointy",
	// "EndPointz",
	"EndPointx_tpcAV",
	// "EndPointy_tpcAV",
	// "EndPointz_tpcAV",
	"pathlen",
	"ntracks_pandoraTrack",
	"ntrkhits_pandoraTrack",
	"trkdqdx_pandoraTrack",
	"trkxyz_pandoraTrack",
	"trklen_pandoraTrack"
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);
    tree->SetMakeClass(1);

    //***** Process *****
    cout<<"Starting a loop over the tree"<<endl;
    int size = tree->GetEntriesFast();
    int entries_processed = 0;
    int entries_passed = 0;
    int tracks_used = 0;
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;

    //size = 50000;
    cout<<"|                                                  |\r|";
    for (int ientry = 0; ientry < size; ++ientry) {
	// print progress
	if ( (ientry+1)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	// get an entry
	int status = tree->GetEntry(ientry);
	if (!status) break;
	entries_processed++;
	int ntracks = evt->ntracks_pandoraTrack;

	// select only clean events
	// true track needs to have at least 2 m path in TPC
	// does not stop in TPC
	if (!evt->inTPCActive[0]) continue;
	if (evt->pathlen[0] < 200.) continue;
	double Eloss = (evt->StartE_tpcAV[0] - evt->EndE_tpcAV[0])*1e3; // in MeV
	if (Eloss/evt->pathlen[0] < 6. ) // must loose < 6 MeV/cm
	    continue;
	if (evt->EndPointx_tpcAV[0] == evt->EndPointx[0])
	    // must exit Active volume. Assuming checking one
	    // coordinate is enough.
	    continue;

	entries_passed++;

	// loop over stored tracks
	for (int itrack = 0; itrack < ntracks; ++itrack) {
	    // make a threshold on reco track length
	    if (evt->trklen_pandoraTrack[itrack] < 200.) continue; // at least 2-m long track
	    tracks_used++;

	    // choose the best plane
	    int best_plane = 0;
	    int tmp_hits = 0;
	    for (int i = 0; i < 3; ++i) {
		if ( evt->ntrkhits_pandoraTrack[itrack][i] > tmp_hits ) {
		    tmp_hits = evt->ntrkhits_pandoraTrack[itrack][i];
		    best_plane = i;
		}
	    }

	    // loop over all planes
	    // loop over hits in the best plane
	    for (int iplane = 0; iplane < 3; ++iplane) {
		for (int i = 0; i < tmp_hits; ++i) {
		    double dqdx = evt->trkdqdx_pandoraTrack[itrack][iplane][i];
		    if ( dqdx != 0.) {
			double x = evt->trkxyz_pandoraTrack[itrack][iplane][i][0];
			double t = x * kXtoT;
			hists[Dqdx_vs_x_plane0 + iplane]->Fill(x, dqdx);
			hists[Dqdx_vs_t_plane0 + iplane]->Fill(t, dqdx);
			if (iplane == best_plane) {
			    hists[Dqdx_vs_x]->Fill(x, dqdx);
			    hists[Dqdx_vs_t]->Fill(t, dqdx);
			}
		    }
		}
	    }

	}// track loop

    }// tree entry loop
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;

    //***** Output file *****
    auto outf = TFile::Open(Form("%sclean_through_anahists.root", outpref), "UPDATE");

    //***** Save hists *****
    for (auto h : hists) {
	h->Write(0, TObject::kOverwrite);
    }

    cout<<entries_passed<<" events passed the cuts."<<endl;
    cout<<tracks_used<<" tracks used."<<endl;

    outf->Close();
    cout<<"Saved and closed output file "<<outf->GetName()<<endl;
}
