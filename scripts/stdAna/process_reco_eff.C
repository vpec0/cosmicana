/**
 * Processes the standard ana files.
 *
 * Filters events to those where muon entered the TPC.
 *
 * Saves only limited data related to gean4 truth and track
 * reconstrcution.
 *
 * To be used for track reconstruction efficiency study.
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"
#include "CosmicMuonEvent.h"

void attachFiles(TChain* tree, const char* fname, int batchNo, int Nruns);
void crossingAPACPA(TVector3 start, TVector3 end, Int_t& napa, Int_t* apa, Int_t& ncpa, Int_t* cpa);



void process_reco_eff(const char* fname = "", const char* outpref = "", int batchNo = 21, int Nruns = 10)
{

    //***** Input tree *****
    auto tree = new TChain("analysistree/anatree");
    attachFiles(tree, fname, batchNo, Nruns);
    anatree* evt = new anatree(tree);

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	"run",
	"event",
    	"geant_list_size",
	"inTPCActive",
	"StartPointx_tpcAV",
	"StartPointy_tpcAV",
	"StartPointz_tpcAV",
	"EndPointx_tpcAV",
	"EndPointy_tpcAV",
	"EndPointz_tpcAV",
	"StartE_tpcAV",
	"EndE_tpcAV",
	"StartPx_tpcAV",
	"StartPy_tpcAV",
	"StartPz_tpcAV",
	"StartP_tpcAV",
	"pathlen",

	"ntracks_pandoraTrack",
	"trkstartx_pandoraTrack",
	"trkstarty_pandoraTrack",
	"trkstartz_pandoraTrack",
	"trkendx_pandoraTrack",
	"trkendy_pandoraTrack",
	"trkendz_pandoraTrack",
	"trkstartdcosx_pandoraTrack",
	"trkstartdcosy_pandoraTrack",
	"trkstartdcosz_pandoraTrack",
	"trklen_pandoraTrack",
	"trkg4id_pandoraTrack",

	"ntracks_pmtrack",
	"trkstartx_pmtrack",
	"trkstarty_pmtrack",
	"trkstartz_pmtrack",
	"trkendx_pmtrack",
	"trkendy_pmtrack",
	"trkendz_pmtrack",
	"trkstartdcosx_pmtrack",
	"trkstartdcosy_pmtrack",
	"trkstartdcosz_pmtrack",
	"trklen_pmtrack",
	"trkg4id_pmtrack",
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);


    //***** Output Tree *****
    auto outf = TFile::Open(Form("%scosmic_muon_recoeff_ana.root", outpref), "RECREATE");
    auto outevt = new CosmicMuonEvent::Event_t();
    auto outtree = CosmicMuonEvent::createTree("cosmicMuons", *outevt);


    //***** Process *****
    cout<<"Starting a loop over the tree"<<endl;
    int size = tree->GetEntriesFast();
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;

    int entries_processed = 0;

    //size = 20;
    cout<<"|                                                  |\r|";
    for (int ientry = 0; ientry < size; ++ientry) {
	// print progress
	if ( (ientry+1)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	// get an entry
	int status = tree->GetEntry(ientry);
	if (!status) break;
	entries_processed++;

	if (! evt->inTPCActive[0]) // primary muon didn't make it to TPC
	    continue;

	// store truth data of the primary muon
	outevt->run = evt->run;
	outevt->event = evt->event;

	outevt->StartPointx_tpcAV = evt->StartPointx_tpcAV[0];
	outevt->StartPointy_tpcAV = evt->StartPointy_tpcAV[0];
	outevt->StartPointz_tpcAV = evt->StartPointz_tpcAV[0];

	outevt->EndPointx_tpcAV = evt->EndPointx_tpcAV[0];
	outevt->EndPointy_tpcAV = evt->EndPointy_tpcAV[0];
	outevt->EndPointz_tpcAV = evt->EndPointz_tpcAV[0];

	outevt->StartE_tpcAV = evt->StartE_tpcAV[0];
	outevt->Eloss = evt->StartE_tpcAV[0] - evt->EndE_tpcAV[0];

	outevt->StartPx_tpcAV = evt->StartPx_tpcAV[0];
	outevt->StartPy_tpcAV = evt->StartPy_tpcAV[0];
	outevt->StartPz_tpcAV = evt->StartPz_tpcAV[0];
	outevt->StartP_tpcAV = evt->StartP_tpcAV[0];

	outevt->pathlen = evt->pathlen[0];

	// cout<<"x1 = "<<evt->StartPointx_tpcAV[0]
	//     <<", x2 = "<<evt->EndPointx_tpcAV[0]<<endl;

	// find and store all APA and CPA crossed
	TVector3 start(evt->StartPointx_tpcAV[0],evt->StartPointy_tpcAV[0],evt->StartPointz_tpcAV[0]);
	TVector3 end(evt->EndPointx_tpcAV[0],evt->EndPointy_tpcAV[0],evt->EndPointz_tpcAV[0]);
	crossingAPACPA(start, end,
		       outevt->nApa, outevt->Apa,
		       outevt->nCpa, outevt->Cpa);

	// store data of reconstructed tracks
#undef INT
#undef DOUBLE_ARRAY
#define INT(var) {}
#define DOUBLE_ARRAY(var, size) outevt->var[outevt->nRecoPandora] = evt->var[i]
	int nreco = evt->ntracks_pandoraTrack;
	for (int i = 0; i < nreco; ++i) {
	    if (evt->trkg4id_pandoraTrack[i] == 1) { // this track is mainly created by the primary particle
		PANDORA_LIST;
		outevt->nRecoPandora++;
		if (outevt->nRecoPandora == CosmicMuonEvent::MAX_TRACKS) {
		    cout<<"Pandora: "<<outevt->nRecoPandora<<endl;
		    break;
		}
	    }
	}

#undef INT
#undef DOUBLE_ARRAY
#define INT(var) {}
#define DOUBLE_ARRAY(var, size) outevt->var[outevt->nRecoPm] = evt->var[i]
	nreco = evt->ntracks_pmtrack;
	for (int i = 0; i < nreco; ++i) {
	    if (evt->trkg4id_pmtrack[i] == 1) { // this track is mainly created by the primary particle
		PM_LIST;
		outevt->nRecoPm++;
		if (outevt->nRecoPm == CosmicMuonEvent::MAX_TRACKS) {
		    cout<<"PM: "<<outevt->nRecoPm<<endl;
		    break;
		}
	    }
	}

	// cout<<"Pandora: "<<outevt->nRecoPandora<<endl;
	// cout<<"PM: "<<outevt->nRecoPm<<endl;

	// fill the event into the tree
	outtree->Fill();
	// reset event
	*outevt = {};
    }// tree entry loop
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;
    cout<<"Storing "<<outtree->GetEntries()<<" entries in output file: "
	<<outf->GetName()<<endl;

    outtree->Write("",TObject::kOverwrite);
    outf->Close();
    cout<<"Saved and closed output file"<<endl;
}



void attachFiles(TChain* tree, const char* fname, int batchNo, int Nruns) {
    if (!strcmp(fname, "")) { // no input given
	cout<<"Will try to add "<<Nruns<<" production files from batch "
	    <<batchNo<<" to the chain."<<endl;
	TString batch = Form("2000%02d", batchNo);
	TString topdir = "/data/kumar/dune/cosmic/largeproduction/data/";
	topdir += batch + "00/";
	for (int j = 0; j<Nruns; j++) {
	    TString fullname = topdir +
		Form(batch + "%02d/MUSUN_dunefd_" + batch + "%02d_gen_g4_detsim_reco_ana.root",
		     j, j);
	    if (gSystem->AccessPathName(fullname))
		continue;
	    int status = tree->Add(fullname, -1);
	}
	cout<<tree->GetNtrees()<<" files added."<<endl;
    } else { // input given
	cout<<"Adding "<<fname<<" to the chain."<<endl;
	int status = tree->Add(fname, -1);
	if (!status) { // try to look in the base dir
	    tree->SetName("anatree");
	    status = tree->Add(fname, -1);
	}
	cout<<"Status: "<<status<<endl;
    }
}

void crossingAPACPA(const TVector3 start, const TVector3 end, Int_t& napa, Int_t* apa, Int_t& ncpa, Int_t* cpa)
{
    double ay, by, az, bz, x1, x2, y1, y2, z1, z2;

    x1 = start.X();
    x2 = end.X();
    y1 = start.Y();
    y2 = end.Y();
    z1 = start.Z();
    z2 = end.Z();

    ay = (y1-y2)/(x1-x2);
    az = (z1-z2)/(x1-x2);

    by = y1 - ay*x1;
    bz = z1 - az*x1;

    int iapa = -1;
    for (auto xapa: CosmicMuonEvent::APA_X_POSITIONS) {
	++iapa;
	if ( (xapa < x1 && xapa < x2) || (xapa > x2 && xapa > x1) )
	    continue; // not crossing this APA section

	// get y and z coordinate of the crossing
	double yapa = ay * xapa + by;
	double zapa = az * xapa + bz;

	// cout<<"Testing APA "<<iapa<<" at "<<xapa<<" cm, "
	//     <<"x1 = "<<x1<<", x2 = "<<x2<<endl;
	// cout<<"APA crossed at ";
	// cout<<Form("(%.1f,%.1f,%.1f)", xapa, yapa, zapa)<<endl;

	// get the APA number
	int apanum = int(zapa / CosmicMuonEvent::TPC_Z_SIZE) * 6 + (yapa>0.)*3 + iapa;

	apa[napa] = apanum;
	++napa;
    }

    int icpa = 0;
    for (auto xcpa: CosmicMuonEvent::CPA_X_POSITIONS) {
	++icpa;

	if ( (xcpa < x1 && xcpa < x2) || (xcpa > x2 && xcpa > x1) )
	    continue; // not crossing this CPA section
	// get y and z coordinate of the crossing
	double ycpa = ay * xcpa + by;
	double zcpa = az * xcpa + bz;

	// cout<<"Testing CPA "<<icpa<<" at "<<xcpa<<" cm"<<endl;
	// cout<<"CPA crossed at ";
	// cout<<Form("(%.1f,%.1f,%.1f)", xcpa, ycpa, zcpa)<<endl;

	// get the CPA number
	int cpanum = int(zcpa / CosmicMuonEvent::TPC_Z_SIZE) * 4 + (ycpa>0.)*2 + icpa;

	cpa[ncpa] = cpanum;
	++ncpa;
    }
}
