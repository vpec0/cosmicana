/**
 * Processes the standard ana files.
 *
 * Filters events to those where muon entered the TPC.
 *
 * Saves only limited data related to gean4 truth and track
 * reconstrcution.
 *
 * To be used for track reconstruction efficiency study.
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"
#include "CosmicMuonEvent.h"

#include "common.icc"


void process_reco_eff(const char* fname = "", const char* outpref = "", int batchNo = 21, int Nruns = 10)
{

    //***** Input tree *****
    auto tree = new TChain("analysistree/anatree");
    attachFiles(tree, fname, batchNo, Nruns);
    anatree* evt = new anatree(tree);

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	"run",
	"event",
    	"geant_list_size",
	"inTPCActive",
	"StartPointx_tpcAV",
	"StartPointy_tpcAV",
	"StartPointz_tpcAV",
	"EndPointx_tpcAV",
	"EndPointy_tpcAV",
	"EndPointz_tpcAV",
	"StartE_tpcAV",
	"EndE_tpcAV",
	"StartPx_tpcAV",
	"StartPy_tpcAV",
	"StartPz_tpcAV",
	"StartP_tpcAV",
	"pathlen",

	"ntracks_pandoraTrack",
	"trkstartx_pandoraTrack",
	"trkstarty_pandoraTrack",
	"trkstartz_pandoraTrack",
	"trkendx_pandoraTrack",
	"trkendy_pandoraTrack",
	"trkendz_pandoraTrack",
	"trkstartdcosx_pandoraTrack",
	"trkstartdcosy_pandoraTrack",
	"trkstartdcosz_pandoraTrack",
	"trklen_pandoraTrack",
	"trkg4id_pandoraTrack",

	"ntracks_pmtrack",
	"trkstartx_pmtrack",
	"trkstarty_pmtrack",
	"trkstartz_pmtrack",
	"trkendx_pmtrack",
	"trkendy_pmtrack",
	"trkendz_pmtrack",
	"trkstartdcosx_pmtrack",
	"trkstartdcosy_pmtrack",
	"trkstartdcosz_pmtrack",
	"trklen_pmtrack",
	"trkg4id_pmtrack",
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);


    //***** Output Tree *****
    auto outf = TFile::Open(Form("%scosmic_muon_recoeff_ana.root", outpref), "RECREATE");
    auto outevt = new CosmicMuonEvent::Event_t();
    auto outtree = CosmicMuonEvent::createTree("cosmicMuons", *outevt);


    //***** Process *****
    cout<<"Starting a loop over the tree"<<endl;
    int size = tree->GetEntriesFast();
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;

    int entries_processed = 0;

    //size = 20;
    cout<<"|                                                  |\r|";
    for (int ientry = 0; ientry < size; ++ientry) {
	// print progress
	if ( (ientry+1)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	// get an entry
	int status = tree->GetEntry(ientry);
	if (!status) break;
	entries_processed++;

	if (! evt->inTPCActive[0]) // primary muon didn't make it to TPC
	    continue;

	// store truth data of the primary muon
	outevt->run = evt->run;
	outevt->event = evt->event;

	outevt->StartPointx_tpcAV = evt->StartPointx_tpcAV[0];
	outevt->StartPointy_tpcAV = evt->StartPointy_tpcAV[0];
	outevt->StartPointz_tpcAV = evt->StartPointz_tpcAV[0];

	outevt->EndPointx_tpcAV = evt->EndPointx_tpcAV[0];
	outevt->EndPointy_tpcAV = evt->EndPointy_tpcAV[0];
	outevt->EndPointz_tpcAV = evt->EndPointz_tpcAV[0];

	outevt->StartE_tpcAV = evt->StartE_tpcAV[0];
	outevt->Eloss = evt->StartE_tpcAV[0] - evt->EndE_tpcAV[0];

	outevt->StartPx_tpcAV = evt->StartPx_tpcAV[0];
	outevt->StartPy_tpcAV = evt->StartPy_tpcAV[0];
	outevt->StartPz_tpcAV = evt->StartPz_tpcAV[0];
	outevt->StartP_tpcAV = evt->StartP_tpcAV[0];

	outevt->pathlen = evt->pathlen[0];

	// cout<<"x1 = "<<evt->StartPointx_tpcAV[0]
	//     <<", x2 = "<<evt->EndPointx_tpcAV[0]<<endl;

	// find and store all APA and CPA crossed
	TVector3 start(evt->StartPointx_tpcAV[0],evt->StartPointy_tpcAV[0],evt->StartPointz_tpcAV[0]);
	TVector3 end(evt->EndPointx_tpcAV[0],evt->EndPointy_tpcAV[0],evt->EndPointz_tpcAV[0]);
	crossingAPACPA(start, end,
		       outevt->nApa, outevt->Apa,
		       outevt->nCpa, outevt->Cpa);

	// store data of reconstructed tracks
#undef INT
#undef DOUBLE_ARRAY
#define INT(var) {}
#define DOUBLE_ARRAY(var, size) outevt->var[outevt->nRecoPandora] = evt->var[i]
	int nreco = evt->ntracks_pandoraTrack;
	for (int i = 0; i < nreco; ++i) {
	    if (evt->trkg4id_pandoraTrack[i] == 1) { // this track is mainly created by the primary particle
		PANDORA_LIST;
		outevt->nRecoPandora++;
		if (outevt->nRecoPandora == CosmicMuonEvent::MAX_TRACKS) {
		    cout<<"Pandora: "<<outevt->nRecoPandora<<endl;
		    break;
		}
	    }
	}

#undef INT
#undef DOUBLE_ARRAY
#define INT(var) {}
#define DOUBLE_ARRAY(var, size) outevt->var[outevt->nRecoPm] = evt->var[i]
	nreco = evt->ntracks_pmtrack;
	for (int i = 0; i < nreco; ++i) {
	    if (evt->trkg4id_pmtrack[i] == 1) { // this track is mainly created by the primary particle
		PM_LIST;
		outevt->nRecoPm++;
		if (outevt->nRecoPm == CosmicMuonEvent::MAX_TRACKS) {
		    cout<<"PM: "<<outevt->nRecoPm<<endl;
		    break;
		}
	    }
	}

	// cout<<"Pandora: "<<outevt->nRecoPandora<<endl;
	// cout<<"PM: "<<outevt->nRecoPm<<endl;

	// fill the event into the tree
	outtree->Fill();
	// reset event
	*outevt = {};
    }// tree entry loop
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;
    cout<<"Storing "<<outtree->GetEntries()<<" entries in output file: "
	<<outf->GetName()<<endl;

    outtree->Write("",TObject::kOverwrite);
    outf->Close();
    cout<<"Saved and closed output file"<<endl;
}
