/**
 * Processes the standard ana files.
 *
 *
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"
#include "CosmicMuonEvent.h"

void attachFiles(TChain* tree, const char* fname, int batchNo, int Nruns);



void process_reco_eff(const char* fname = "", const char* outpref = "", int batchNo = 21, int Nruns = 10)
{

    //***** Input tree *****
    auto tree = new TChain("analysistree/anatree");
    attachFiles(tree, fname, batchNo, Nruns);
    anatree* evt = new anatree(tree);

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	"run",
	"event",
    	"geant_list_size",
	"inTPCActive",
	"StartPointx_tpcAV",
	"StartPointy_tpcAV",
	"StartPointz_tpcAV",
	"EndPointx_tpcAV",
	"EndPointy_tpcAV",
	"EndPointz_tpcAV",
	"StartE_tpcAV",
	"EndE_tpcAV",
	"StartPx_tpcAV",
	"StartPy_tpcAV",
	"StartPz_tpcAV",
	"StartP_tpcAV",
	"pathlen",

	"ntracks_pandoraTrack",
	"trkstartx_pandoraTrack",
	"trkstarty_pandoraTrack",
	"trkstartz_pandoraTrack",
	"trkendx_pandoraTrack",
	"trkendy_pandoraTrack",
	"trkendz_pandoraTrack",
	"trkstartdcosx_pandoraTrack",
	"trkstartdcosy_pandoraTrack",
	"trkstartdcosz_pandoraTrack",
	"trklen_pandoraTrack",
	"trkg4id_pandoraTrack",

	"ntracks_pmtrack",
	"trkstartx_pmtrack",
	"trkstarty_pmtrack",
	"trkstartz_pmtrack",
	"trkendx_pmtrack",
	"trkendy_pmtrack",
	"trkendz_pmtrack",
	"trkstartdcosx_pmtrack",
	"trkstartdcosy_pmtrack",
	"trkstartdcosz_pmtrack",
	"trklen_pmtrack",
	"trkg4id_pmtrack",
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);


    //***** Output Tree *****
    auto outf = TFile::Open(Form("%scosmic_muon_recoeff_ana.root", outpref), "RECREATE");
    auto outevt = new CosmicMuonEvent::Event_t();
    auto outtree = CosmicMuonEvent::createTree("cosmicMuons", *outevt);


    //***** Process *****
    cout<<"Starting a loop over the tree"<<endl;
    int size = tree->GetEntriesFast();
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;

    int entries_processed = 0;

    //size = 50000;
    cout<<"|                                                  |\r|";
    for (int ientry = 0; ientry < size; ++ientry) {
	// print progress
	if ( (ientry+1)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	// get an entry
	int status = tree->GetEntry(ientry);
	if (!status) break;
	entries_processed++;

	if (! evt->inTPCActive[0]) // primary muon didn't make it to TPC
	    continue;

	// store truth data of the primary muon
	outevt->run = evt->run;
	outevt->event = evt->event;

	outevt->StartPointx_tpcAV = evt->StartPointx_tpcAV[0];
	outevt->StartPointy_tpcAV = evt->StartPointy_tpcAV[0];
	outevt->StartPointz_tpcAV = evt->StartPointz_tpcAV[0];

	outevt->EndPointx_tpcAV = evt->EndPointx_tpcAV[0];
	outevt->EndPointy_tpcAV = evt->EndPointy_tpcAV[0];
	outevt->EndPointz_tpcAV = evt->EndPointz_tpcAV[0];

	outevt->StartE_tpcAV = evt->StartE_tpcAV[0];
	outevt->Eloss = evt->StartE_tpcAV[0] - evt->EndE_tpcAV[0];

	outevt->StartPx_tpcAV = evt->StartPx_tpcAV[0];
	outevt->StartPy_tpcAV = evt->StartPy_tpcAV[0];
	outevt->StartPz_tpcAV = evt->StartPz_tpcAV[0];
	outevt->StartP_tpcAV = evt->StartP_tpcAV[0];

	outevt->pathlen = evt->pathlen[0];

	// store data of reconstructed tracks
#undef INT
#undef DOUBLE_ARRAY
#define INT(var) {}
#define DOUBLE_ARRAY(var, size) outevt->var[outevt->nRecoPandora] = evt->var[i]
	int nreco = evt->ntracks_pandoraTrack;
	for (int i = 0; i < nreco; ++i) {
	    if (evt->trkg4id_pandoraTrack[i] == 1) { // this track is mainly created by the primary particle
		PANDORA_LIST;
		outevt->nRecoPandora++;
		if (outevt->nRecoPandora == CosmicMuonEvent::MAX_TRACKS) {
		    cout<<"Pandora: "<<outevt->nRecoPandora<<endl;
		    break;
		}
	    }
	}

#undef INT
#undef DOUBLE_ARRAY
#define INT(var) {}
#define DOUBLE_ARRAY(var, size) outevt->var[outevt->nRecoPm] = evt->var[i]
	nreco = evt->ntracks_pmtrack;
	for (int i = 0; i < nreco; ++i) {
	    if (evt->trkg4id_pmtrack[i] == 1) { // this track is mainly created by the primary particle
		PM_LIST;
		outevt->nRecoPm++;
		if (outevt->nRecoPm == CosmicMuonEvent::MAX_TRACKS) {
		    cout<<"PM: "<<outevt->nRecoPm<<endl;
		    break;
		}
	    }
	}

	// cout<<"Pandora: "<<outevt->nRecoPandora<<endl;
	// cout<<"PM: "<<outevt->nRecoPm<<endl;

	// fill the event into the tree
	outtree->Fill();
	// reset event
	*outevt = {};
    }// tree entry loop
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;
    cout<<"Storing "<<outtree->GetEntries()<<" entries in output file: "
	<<outf->GetName()<<endl;

    outtree->Write("",TObject::kOverwrite);
    outf->Close();
    cout<<"Saved and closed output file"<<endl;
}



void attachFiles(TChain* tree, const char* fname, int batchNo, int Nruns) {
    if (!strcmp(fname, "")) { // no input given
	cout<<"Will try to add "<<Nruns<<" production files from batch "
	    <<batchNo<<" to the chain (unchecked)."<<endl;
	TString batch = Form("2000%02d", batchNo);
	TString topdir = "/data/kumar/dune/cosmic/largeproduction/data/";
	topdir += batch + "00/";
	for (int j = 0; j<Nruns; j++) {
	    TString fullname = topdir +
		Form(batch + "%02d/MUSUN_dunefd_" + batch + "%02d_gen_g4_detsim_reco_ana.root",
		     j, j);
	    if (gSystem->AccessPathName(fullname))
		continue;
	    int status = tree->Add(fullname, 500);
	}
	cout<<tree->GetNtrees()<<" files added."<<endl;
    } else { // input given
	cout<<"Adding "<<fname<<" to the chain."<<endl;
	int status = tree->Add(fname, -1);
	if (!status) { // try to look in the base dir
	    tree->SetName("anatree");
	    status = tree->Add(fname, -1);
	}
	cout<<"Status: "<<status<<endl;
    }
}
