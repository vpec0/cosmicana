/**
 * Processes the standard ana files.
 *
 * First attempt on simple electron life-time measurement
 *
 *
 * anatree_core.h (generated by the TTree::MakeClass() method) and
 * anatree.h (a wrapper for the former) are needed
 **/


#include "anatree.h"

#include "FileHandler.h"
#include "common.icc"

#define FOR(i,size) for (int i = 0; i < size; ++i)

int whichTPC(double);

const double kXtoT = 1./160.563; // converts cm to ms, calculated for field 0.5kV/cm and temperature 87K
const double WireAngle[3] = {-35.7, 35.7, 0.};
const double toDeg = TMath::RadToDeg();
const double toRad = TMath::DegToRad();

void process_dqdx_vs_x_thetayxz_binned(const char* fname = "", const char* outpref = "",
				       int batchNo = 20002100, size_t Nruns = 10, size_t startRun = 0,
				       const char* data_version = "v08_34_00", const char* source = "")
{

    vector<TH1*> hists;

    FOR(iplane, 3) {
	//if (iplane != 2) continue; // For now, do only collection plane
	hists.push_back(new TH3F(Form("Dqdx_vs_x_plane%d", iplane),
				 Form("dQ/dx vs x plane %d;x [cm]", iplane),
				 160, -800, 800, 250, 0, 500, 4, 0., 4.) );
    }

    //***** Input tree *****
    auto tree = new TChain("analysistree/anatree");
    size_t size = FileHandler::attachFiles(tree, fname, batchNo, Nruns, startRun, data_version, source);
    anatree* evt = new anatree(tree);

    // allow only selected branches!
    //
    // This improves the speed of the tree processing. Any branch to
    // be used needs to be added here, otherwise we don't get any data
    // from it.
    std::vector<TString> allowed = {
	// "run",
	// "event",
    	// "geant_list_size",
	// "inTPCActive",
	// "Eng",
	// "Mother",
	// "TrackId",
	// "pdg",
	// "processname",
	// "StartE_tpcAV",
	// "StartPx_tpcAV",
	// "StartPy_tpcAV",
	// "StartPz_tpcAV",
	// "StartP_tpcAV",
	// "EndE_tpcAV",
	// "EndPointx",
	// "EndPointy",
	// "EndPointz",
	// "EndPointx_tpcAV",
	// "EndPointy_tpcAV",
	// "EndPointz_tpcAV",
	// "pathlen",
	"ntracks_pandoraTrack",
	"trklen_pandoraTrack",
	"trkstartdcosx_pandoraTrack",
	"trkstartdcosy_pandoraTrack",
	"trkstartdcosz_pandoraTrack",
	"ntrkhits_pandoraTrack",
	"trkdqdx_pandoraTrack",
	//"trkdedx_pandoraTrack",
	"trkxyz_pandoraTrack"
    };
    tree->SetBranchStatus("*", 0);
    AnaTree::AllowBranches(tree, allowed);
    tree->SetMakeClass(1);

    //***** Process *****
    cout<<"Starting a loop over the tree"<<endl;
    int entries_processed = 0;
    int fiftieth = size / 50;
    cout<<"Will loop over "<<size<<" entries."<<endl;


    size_t events_passing_selection = 0;
    size_t tracks_passing_selection = 0;

    //size = 50000;
    cout<<"|                                                  |\r|";
    size_t ientry = 0;
    while ( tree->GetEntry(ientry++) ) {
	// print progress
	if ( (ientry)%fiftieth == 0) {
	    cout<<"-";
	    cout.flush();
	}

	entries_processed++;
	int ntracks = evt->ntracks_pandoraTrack;

	// loop over stored tracks
	bool passed = false ;
	for (int itrack = 0; itrack < ntracks; ++itrack) {
	    // make a threshold on reco track length
	    if (evt->trklen_pandoraTrack[itrack] < 200.) continue; // at least 2-m long track
	    if (!passed) passed = true;

	    ++tracks_passing_selection;

	    TVector3 dir(evt->trkstartdcosx_pandoraTrack[itrack],
			 evt->trkstartdcosy_pandoraTrack[itrack],
			 evt->trkstartdcosz_pandoraTrack[itrack]);


	    // loop over all planes
	    // loop over hits in the best plane
	    //
	    for (int iplane = 0; iplane < 3; ++iplane) {
		if (iplane != 2) continue; // For now, do only collection plane
		TVector3 tmpdir = dir;
		// tmpdir.RotateX(-WireAngle[iplane]*toRad);
		double theta_xz = TMath::ATan2(tmpdir.X(), tmpdir.Z()) * toDeg;
		double theta_y = TMath::ACos(tmpdir.Y()) * toDeg;

		int bin = 3; // the rest
		if (theta_y > 160.) bin = 0; // vertical
		else if (abs(abs(theta_xz) - 90.) < 20.) bin = 1; // pointed towards APA
		else if (abs(abs(theta_xz) - 180.) < 10. || abs(theta_xz) < 10.) bin = 2; // parallel to APA

		int nhits = evt->ntrkhits_pandoraTrack[itrack][iplane];
		TH3* tmph = (TH3*)hists[iplane];
		for (int i = 0; i < nhits; ++i) {
		    double dqdx = evt->trkdqdx_pandoraTrack[itrack][iplane][i];
		    if ( dqdx != 0.) {
			double x = evt->trkxyz_pandoraTrack[itrack][iplane][i][0];
			tmph->Fill(x, dqdx, bin);
		    }
		}
	    }

	}// track loop

	if (passed)
	    ++events_passing_selection;

    }// tree entry loop
    cout<<"|"<<endl;

    cout<<"Done."<<endl;
    cout<<"Processed "<<entries_processed<<" entries."<<endl;
    cout<<"Events passing selection: "<<events_passing_selection<<endl
	<<"Tracks passing selection: "<<tracks_passing_selection<<endl;

    //***** Output file *****
    auto outf = TFile::Open(Form("%sdqdx_hists_thetayxz_binned.root", outpref), "recreate");

    //***** Save hists *****
    for (auto h : hists) {
	h->Write(0, TObject::kOverwrite);
    }

    outf->Close();
    cout<<"Saved and closed output file "<<outf->GetName()<<endl;
}

int whichTPC(double x) {
    int i = 0;
    for (; i < 4; ++i) {
	int iapa = (i+1)/2;
	int icpa = i/2;
	double xapa = APA_X_POSITIONS[iapa];
	double xcpa = CPA_X_POSITIONS[icpa];
	if ( (x > xapa && x < xcpa) || (x < xapa && x > xcpa) )
	    break;
    }

    return i;
}
